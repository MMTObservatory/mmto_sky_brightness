# PypeIt reduction rules.
[rdx]
    # Spectrograph that provided the data to be reduced.  See
    # :ref:`instruments` for valid options.
    spectrograph = mmt_bluechannel
    # Restrict reduction to a list of detector indices.This cannot (and
    # should not) be used with slitspatnum.
    detnum = None
    # A filename given to output the details of the sorted files.  If
    # None, the default is the root name of the pypeit file.  If off, no
    # output is produced.
    sortroot = None
    # The window of time in hours to search for calibration frames for a
    # science frame
    calwin = 0
    # Directory relative to calling directory to write science files.
    scidir = Science
    # Directory relative to calling directory to write quality
    # assessment files.
    qadir = QA
    # Path to folder for performing reductions.  Default is the current
    # working directory.
    redux_path = /mnt/d/sky_brightness/mmto_sky_brightness/20191005/pypeit
    # Ignore bad headers (NOT recommended unless you know it is safe).
    ignore_bad_headers = False
    # Restrict reduction to a set of slit DET:SPAT values (closest slit
    # is used). Example syntax -- slitspatnum = 1:175,1:205   If you are
    # re-running the code, (i.e. modifying one slit) you *must* have the
    # precise SPAT_ID index.This cannot (and should not) be used with
    # detnum
    slitspatnum = None
# Parameters for the calibration algorithms
[calibrations]
    # If provided, it should be the name of the folder to write master
    # files. NOT A PATH.
    master_dir = Masters
    # If masters='force', this is the setup name to be used: e.g.,
    # C_02_aa .  The detector number is ignored but the other
    # information must match the Master Frames in the master frame
    # folder.
    setup = None
    # Make a bad pixel mask from bias frames? Bias frames must be
    # provided.
    bpm_usebias = False
    # Raise an error if the calibration check fails
    raise_chk_error = True
    # The frames and combination rules for the bias correction
    [[biasframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = bias
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = False
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = median
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the dark-current correction
    [[darkframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = dark
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = 300, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = False
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = False
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the wavelength calibration
    [[arcframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = arc
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = 10, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = -1
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the wavelength tilts
    [[tiltframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = tilt
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = -1
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the pixel flat
    [[pixelflatframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = pixelflat
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 100
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = nothing
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the pinholes
    [[pinholeframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = pinhole
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = True
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = True
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the align frames
    [[alignframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = align
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = nothing
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = -1
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # Define the procedure for the alignment of traces
    [[alignment]]
        # Locations of the bars, in a list, specified as a fraction of
        # the slit width
        locations = 0.0, 0.5, 1.0
        # Order of the polynomial to use when fitting the trace of a
        # single bar
        trace_npoly = 8
        # Trim the slit by this number of pixels left/right before
        # finding alignment bars
        trim_edge = 0, 0
        # Significance threshold for finding an alignment trace. This
        # should be a lownumber to ensure that the algorithm finds all
        # bars. The algorithm willthen only use the N most significant
        # detections, where N is the numberof elements specified in the
        # "locations" keyword argument
        sig_thresh = 1.0
    # The frames and combination rules for images used for slit tracing
    [[traceframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = trace
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 100
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the illumination flat
    [[illumflatframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = illumflat
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = 30, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = nothing
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the spectrophotometric
    # standard observations
    [[standardframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt
        frametype = standard
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 600
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, weightmean
            combine = weightmean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = True
            # Perform sigma clipping when combining.  Only used with
            # combine=weightmean
            clip = True
            # Sigma level to reject cosmic rays (<= 0.0 means no CR
            # removal)
            cr_sigrej = 20.0
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # If all pixels are rejected, replace them using this
            # method.  Options are: min, max, mean, median, weightmean,
            # maxnonsat
            replace = maxnonsat
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = True
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = True
            # Use the relative spectral illumination profiles to correct
            # the spectralillumination profile of each slit. This is
            # primarily used for IFUs.
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidalalong one direction, with a frequency that
            # is constant across the detector.
            use_pattern = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # Parameters used to set the flat-field procedure
    [[flatfield]]
        # Method used to flat field the data; use skip to skip flat-
        # fielding.  Options are: None, bspline, skip
        method = bspline
        # Filename of the image to use for pixel-level field flattening
        pixelflat_file = None
        # bspline break point spacing in units of pixels for spectral
        # fit to flat field blaze function.
        spec_samp_fine = 1.2
        # bspline break point spacing in units of pixels for 2-d
        # bspline-polynomial fit to flat field image residuals. This
        # should be a large number unless you are trying to fit a sky
        # flat with lots of narrow spectral features.
        spec_samp_coarse = 50.0
        # Spatial sampling for slit illumination function. This is the
        # width of the median filter in pixels used to determine the
        # slit illumination function, and thus sets the minimum scale on
        # which the illumination function will have features.
        spat_samp = 5.0
        # Use the illumination flat field to tweak the slit edges. This
        # will work even if illumflatten is set to False
        tweak_slits = True
        # If tweak_slits is True, this sets the illumination function
        # threshold used to tweak the slit boundaries based on the
        # illumination flat. It should be a number less than 1.0
        tweak_slits_thresh = 0.93
        # If tweak_slit is True, this sets the maximum fractional amount
        # (of a slits width) allowed for trimming each (i.e. left and
        # right) slit boundary, i.e. the default is 10% which means
        # slits would shrink or grow by at most 20% (10% on each side)
        tweak_slits_maxfrac = 0.1
        # Propagate the rejected pixels through the stages of the flat-
        # field fitting (i.e, from the spectral fit, to the spatial fit,
        # and finally to the 2D residual fit).  If False, pixels
        # rejected in each stage are included in each subsequent stage.
        rej_sticky = False
        # The number of pixels to trim each side of the slit when
        # selecting pixels to use for fitting the spectral response
        # function.  Single values are used for both slit edges; a two-
        # tuple can be used to trim the left and right sides
        # differently.
        slit_trim = 3.0
        # The number of pixels to pad the slit edges when constructing
        # the slit-illumination profile. Single value applied to both
        # edges.
        slit_illum_pad = 5.0
        # The number of rejection iterations to perform when
        # constructing the slit-illumination profile.  No rejection
        # iterations are performed if 0.  WARNING: Functionality still
        # being tested.
        illum_iter = 0
        # The sigma threshold used in the rejection iterations used to
        # refine the slit-illumination profile.  Rejection iterations
        # are only performed if ``illum_iter > 0``.
        illum_rej = 5.0
        # Order of polynomial used in the 2D bspline-polynomial fit to
        # flat-field image residuals. The code determines the order of
        # these polynomials to each slit automatically depending on the
        # slit width, which is why the default is None. Alter this
        # paramter at your own risk!
        twod_fit_npoly = None
        # Behavior when a slit is encountered with a large fraction of
        # saturated pixels in the flat-field.  The options are: 'crash'
        # - Raise an error and halt the data reduction; 'mask' - Mask
        # the slit, meaning no science data will be extracted from the
        # slit; 'continue' - ignore the flat-field correction, but
        # continue with the reduction.
        saturated_slits = crash
        # Generate an image of the relative spectral illuminationfor a
        # multi-slit setup.
        slit_illum_relative = False
    # Parameters used to derive the wavelength solution
    [[wavelengths]]
        # Perform wavelength calibration with an arc, sky frame.  Use
        # 'pixel' for no wavelength solution.
        reference = arc
        # Method to use to fit the individual arc lines.  Note that most
        # of the available methods should not be used; they are unstable
        # and require significant parameter tweaking to succeed.  You
        # should useeither 'holy-grail' or 'reidentify': 'holy-grail'
        # attempts to get a first guess at line IDs by looking for
        # patterns in the line locations.  It is fully automated.  When
        # it works, it works well; however, it can fail
        # catastrophically.  Instead, 'reidentify' is the preferred
        # method.  It requires an archived wavelength solution for your
        # specific instrument/grating combination as a reference.  This
        # is used to anchor the wavelength solution for the data being
        # reduced.  All options are: simple, semi-brute, basic, holy-
        # grail, identify, reidentify, full_template
        method = holy-grail
        # Is this an echelle spectrograph? If yes an additional 2-d fit
        # wavelength fit will be performed as a function of spectral
        # pixel and order number to improve the wavelength solution
        echelle = False
        # Is this a fixed format echelle?  If so reidentification will
        # assume that each order in the data is aligned with a single
        # order in the reid arxiv.
        ech_fix_format = True
        # For echelle spectrographs, this is the order of the final 2d
        # fit to the spectral dimension.  You should choose this to be
        # the n_final of the fits to the individual orders.
        ech_nspec_coeff = 4
        # For echelle spectrographs, this is the order of the final 2d
        # fit to the order dimension.
        ech_norder_coeff = 4
        # For echelle spectrographs, this is the sigma-clipping
        # rejection threshold in the 2d fit to spectral and order
        # dimensions
        ech_sigrej = 2.0
        # Name of one or more ions used for the wavelength calibration.
        # Use None for no calibration.
        lamps = ArI, ArII, HeI, NeI
        # Sigma threshold above fluctuations for arc-line detection.
        # Arcs are continuum subtracted and the fluctuations are
        # computed after continuum subtraction.  This can be a single
        # number or a vector (list or numpy array) that provides the
        # detection threshold for each slit.
        sigdetect = 5.0
        # Spectral sampling of the arc lines. This is the FWHM of an
        # arcline in *unbinned* pixels.
        fwhm = 5.0
        # Name of the archival wavelength solution file that will be
        # used for the wavelength reidentification.  Only used if
        # ``method`` is 'reidentify'
        reid_arxiv = None
        # Minimum number of times that a given candidate reidentified
        # line must be properly matched with a line in the arxiv to be
        # considered a good reidentification. If there is a lot of
        # duplication in the arxiv of the spectra in question (i.e.
        # multislit) set this to a number like 1-4. For echelle this
        # depends on the number of solutions in the arxiv.  Set this to
        # 1 for fixed format echelle spectrographs.  For an echelle with
        # a tiltable grating, this will depend on the number of
        # solutions in the arxiv.
        nreid_min = 1
        # Threshold for the *global* cross-correlation coefficient
        # between an input spectrum and member of the archive required
        # to attempt reidentification.  Spectra from the archive with a
        # lower cross-correlation are not used for reidentification.
        # This can be a single number or a list/array providing the
        # value for each slit.
        cc_thresh = 0.7
        # Threshold for the *local* cross-correlation coefficient,
        # evaluated at each reidentified line,  between an input
        # spectrum and the shifted and stretched archive spectrum above
        # which a line must be to be considered a good line for
        # reidentification. The local cross-correlation is evaluated at
        # each candidate reidentified line (using a window of
        # nlocal_cc), and is then used to score the the reidentified
        # lines to arrive at the final set of good reidentifications.
        cc_local_thresh = 0.7
        # Size of pixel window used for local cross-correlation
        # computation for each arc line. If not an odd number one will
        # be added to it to make it odd.
        nlocal_cc = 11
        # Minimum RMS for keeping a slit/order solution. This can be a
        # single number or a list/array providing the value for each
        # slit.
        rms_threshold = 0.5
        # Matching tolerance in pixels when searching for new lines.
        # This is the difference in pixels between the wavlength
        # assigned to an arc line by an iteration of the wavelength
        # solution to the wavelength in the line list.  This parameter
        # is also used as the matching tolerance in pixels for a line
        # reidentification.  A good line match must match within this
        # tolerance to the shifted and stretched archive spectrum, and
        # the archive wavelength solution at this match must be within
        # match_toler dispersion elements from the line in line list.
        match_toler = 2.0
        # Function used for wavelength solution fits
        func = legendre
        # Order of first guess fit to the wavelength solution.
        n_first = 2
        # Order of final fit to the wavelength solution (there are
        # n_final+1 parameters in the fit). This can be a single number
        # or a list/array providing the value for each slit
        n_final = 4
        # Number of sigma for rejection for the first guess to the
        # wavelength solution.
        sigrej_first = 2.0
        # Number of sigma for rejection for the final guess to the
        # wavelength solution.
        sigrej_final = 3.0
        # Central wavelength. Backwards compatibility with basic and
        # semi-brute algorithms.
        wv_cen = 0.0
        # Dispersion. Backwards compatibility with basic and semi-brute
        # algorithms.
        disp = 0.0
        # Number of brightest arc lines to search for in preliminary
        # identification
        numsearch = 20
        # Number of pixels to fit when deriving the centroid of the arc
        # lines (an odd number is best)
        nfitpix = 5
        # One or more pixels at which to manually identify a line
        IDpixels = None
        # Wavelengths of the manually identified lines
        IDwaves = None
        # Frame of reference for the wavelength calibration.  Options
        # are: observed, heliocentric, barycentric
        refframe = heliocentric
        # Number of spectra to chop the arc spectrum into when
        # ``method`` is 'full_template'
        nsnippet = 2
    # Slit-edge tracing parameters
    [[slitedges]]
        # Number of median-filtering iterations to perform on
        # sqrt(trace) image before applying to Sobel filter to detect
        # slit/order edges.
        filt_iter = 0
        # Mode for Sobel filtering.  Default is 'nearest'; note we
        # find'constant' works best for DEIMOS.
        sobel_mode = nearest
        # Threshold for finding edges in the Sobel-filtered significance
        # image.
        edge_thresh = 20.0
        # In the initial connection of spectrally adjacent edge
        # detections, this sets the number of previous spectral rows to
        # consider when following slits forward.
        follow_span = 20
        # The minimum spectral length (as a fraction of the detector
        # size) of a trace determined by direct measurements of the
        # detector data (as opposed to what should be included in any
        # modeling approach; see fit_min_spec_length).
        det_min_spec_length = 0.33
        # Maximum spatial shift in pixels between an input edge location
        # and the recentroided value.
        max_shift_abs = 0.5
        # Maximum spatial shift in pixels between the edges in adjacent
        # spectral positions.
        max_shift_adj = 0.15
        # Maximum error in the spatial position of edges in pixels.
        max_spat_error = None
        # Same-side slit edges below this separation in pixels are
        # considered part of the same edge.
        match_tol = 3.0
        # Function fit to edge measurements.  Options are: polynomial,
        # legendre, chebyshev
        fit_function = legendre
        # Order of the function fit to edge measurements.
        fit_order = 5
        # Maximum deviation between the fitted and measured edge
        # position for rejection in spatial pixels.
        fit_maxdev = 5.0
        # Maximum number of rejection iterations during edge fitting.
        fit_maxiter = 25
        # Number of iterations of re-measuring and re-fitting the edge
        # data; see :func:`pypeit.core.trace.fit_trace`.
        fit_niter = 1
        # Minimum unmasked spectral length of a traced slit edge to use
        # in any modeling procedure (polynomial fitting or PCA
        # decomposition).
        fit_min_spec_length = 0.6
        # During automated tracing, attempt to construct a PCA
        # decomposition of the traces. When True, the edge traces
        # resulting from the initial detection, centroid refinement, and
        # polynomial fitting must meet a set of criteria for performing
        # the pca; see :func:`pypeit.edgetrace.EdgeTraceSet.can_pca`.
        # If False, the ``sync_predict`` parameter *cannot* be set to
        # ``pca``; if it is not, the value is set to ``nearest`` and a
        # warning is issued when validating the parameter set.
        auto_pca = True
        # Construct a PCA decomposition for the left and right traces
        # separately.  This can be important for cross-dispersed echelle
        # spectrographs (e.g., Keck-NIRES)
        left_right_pca = False
        # Minimum number of edge traces required to perform a PCA
        # decomposition of the trace form.  If left_right_pca is True,
        # this minimum applies to the number of left and right traces
        # separately.
        pca_min_edges = 4
        # The number of PCA components to keep, which must be less than
        # the number of detected traces.  If not provided, determined by
        # calculating the minimum number of components required to
        # explain a given percentage of variance in the edge data; see
        # `pca_var_percent`.
        pca_n = None
        # The percentage (i.e., not the fraction) of the variance in the
        # edge data accounted for by the PCA used to truncate the number
        # of PCA coefficients to keep (see `pca_n`).  Ignored if `pca_n`
        # is provided directly.
        pca_var_percent = 99.8
        # Type of function fit to the PCA coefficients for each
        # component.  Options are: polynomial, legendre, chebyshev
        pca_function = polynomial
        # Order of the function fit to the PCA coefficients.
        pca_order = 2
        # Sigma rejection threshold for fitting PCA components.
        # Individual numbers are used for both lower and upper
        # rejection. A list of two numbers sets these explicitly (e.g.,
        # [2., 3.]).
        pca_sigrej = 2.0, 2.0
        # Maximum number of PCA coefficients rejected during a given fit
        # iteration.
        pca_maxrej = 1
        # Maximum number of rejection iterations when fitting the PCA
        # coefficients.
        pca_maxiter = 25
        # Range of the slit in the spectral direction (in fractional
        # units) to smash when searching for slit edges.  If the
        # spectrum covers only a portion of the image, use that range.
        smash_range = 0.0, 1.0
        # Sigma clipping level for peaks detected in the collapsed,
        # Sobel-filtered significance image.
        edge_detect_clip = None
        # After detection of peaks in the rectified Sobel-filtered image
        # and before refitting the edge traces, the rectified image is
        # median filtered with a kernel width of
        # `trace_median_frac*nspec` along the spectral dimension.
        trace_median_frac = None
        # After rectification and median filtering of the Sobel-filtered
        # image (see `trace_median_frac`), values in the median-filtered
        # image *below* this threshold are masked in the refitting of
        # the edge trace data.  If None, no masking applied.
        trace_thresh = None
        # The `fwhm` parameter to use when using uniform weighting in
        # :func:`pypeit.core.trace.fit_trace` when refining the PCA
        # predictions of edges.  See description of
        # :func:`pypeit.core.trace.peak_trace`.
        fwhm_uniform = 3.0
        # The number of iterations of
        # :func:`pypeit.core.trace.fit_trace` to use when using uniform
        # weighting.
        niter_uniform = 9
        # The `fwhm` parameter to use when using Gaussian weighting in
        # :func:`pypeit.core.trace.fit_trace` when refining the PCA
        # predictions of edges.  See description
        # :func:`pypeit.core.trace.peak_trace`.
        fwhm_gaussian = 3.0
        # The number of iterations of
        # :func:`pypeit.core.trace.fit_trace` to use when using Gaussian
        # weighting.
        niter_gaussian = 6
        # The minimum separation between the detector edges and a slit
        # edge for any added edge traces.  Must be positive.
        det_buffer = 5
        # If parts of any (predicted) trace fall off the detector edge,
        # allow them to be nudged away from the detector edge up to and
        # including this maximum number of pixels.  If None, no limit is
        # set; otherwise should be 0 or larger.
        max_nudge = None
        # Mode to use when predicting the form of the trace to insert.
        # Use `pca` to use the PCA decomposition or `nearest` to
        # reproduce the shape of the nearest trace.
        sync_predict = nearest
        # Mode to use for determining the location of traces to insert.
        # Use `median` to use the median of the matched left and right
        # edge pairs, `nearest` to use the length of the nearest slit,
        # or `gap` to offset by a fixed gap width from the next slit
        # edge.
        sync_center = median
        # Offset (pixels) used for the slit edge gap width when
        # inserting slit edges (see `sync_center`) or when nudging
        # predicted slit edges to avoid slit overlaps.  This should be
        # larger than `minimum_slit_gap` when converted to arcseconds.
        gap_offset = 5.0
        # If adding a first left edge or a last right edge, ignore
        # `center_mode` for these edges and place them at the edge of
        # the detector (with the relevant shape).
        sync_to_edge = True
        # Minimum slit length in arcsec.  Slit lengths are determined by
        # the median difference between the left and right edge
        # locations for the unmasked trace locations.  This is used to
        # identify traces that are *erroneously* matched together to
        # form slits.  Short slits are expected to be ignored or removed
        # (see  ``clip``).  If None, no minimum slit length applied.
        minimum_slit_length = None
        # Minimum slit length in arcsec for a science slit.  Slit
        # lengths are determined by the median difference between the
        # left and right edge locations for the unmasked trace
        # locations.  Used in combination with ``minimum_slit_length``,
        # this parameter is used to identify box or alignment slits;
        # i.e., those slits that are shorter than
        # ``minimum_slit_length_sci`` but larger than
        # ``minimum_slit_length`` are box/alignment slits.  Box slits
        # are *never* removed (see ``clip``), but no spectra are
        # extracted from them.  If None, no minimum science slit length
        # is applied.
        minimum_slit_length_sci = None
        # Allowed range in slit length compared to the median slit
        # length.  For example, a value of 0.3 means that slit lengths
        # should not vary more than 30%.  Relatively shorter or longer
        # slits are masked or clipped.  Most useful for echelle or
        # multi-slit data where the slits should have similar or
        # identical lengths.
        length_range = None
        # Minimum slit gap in arcsec.  Gaps between slits are determined
        # by the median difference between the right and left edge
        # locations of adjacent slits.  Slits with small gaps are merged
        # by removing the intervening traces.If None, no minimum slit
        # gap is applied.  This should be smaller than `gap_offset` when
        # converted to pixels.
        minimum_slit_gap = None
        # Remove traces flagged as bad, instead of only masking them.
        # This is currently only used by
        # :func:`~pypeit.edgetrace.EdgeTraceSet.centroid_refine`.
        clip = True
        # For echelle spectrographs, this is the tolerance allowed for
        # matching identified "slits" to echelle orders. Must be in the
        # fraction of the detector spatial scale (i.e., a value of 0.05
        # means that the order locations must be within 5% of the
        # expected value).  If None, no limit is used.
        order_match = None
        # Offset to introduce to the expected order positions to improve
        # the match for this specific data. This is an additive offset
        # to the measured slit positions; i.e., this should minimize the
        # difference between the expected order positions and
        # ``self.slit_spatial_center() + offset``. Must be in the
        # fraction of the detector spatial scale. If None, no offset is
        # applied.
        order_offset = None
        # Use slit-mask designs to identify slits.
        use_maskdesign = False
        # Maximum allowed offset in pixels between the slit edges
        # defined by the slit-mask design and the traced edges.
        maskdesign_maxsep = 50
        # Step in pixels used to generate a list of possible offsets
        # (within +/- `maskdesign_maxsep`) between the slit edges
        # defined by the mask design and the traced edges.
        maskdesign_step = 1
        # Number of sigma for sigma-clipping rejection during slit-mask
        # design matching.
        maskdesign_sigrej = 3
        # Integer number of pixels to consider beyond the slit edges
        # when selecting pixels that are 'on' the slit.
        pad = 0
        # Add one or more user-defined slits.  The syntax to define a
        # slit to add is: 'det:spec:spat_left:spat_right' where
        # det=detector, spec=spectral pixel, spat_left=spatial pixel of
        # left slit boundary, and spat_righ=spatial pixel of right slit
        # boundary.  For example, '2:2000:2121:2322,3:2000:1201:1500'
        # will add a slit to detector 2 passing through spec=2000
        # extending spatially from 2121 to 2322 and another on detector
        # 3 at spec=2000 extending from 1201 to 1500.
        add_slits = None
        # Remove one or more user-specified slits.  The syntax used to
        # define a slit to remove is: 'det:spec:spat' where
        # det=detector, spec=spectral pixel, spat=spatial pixel.  For
        # example, '2:2000:2121,3:2000:1500' will remove the slit on
        # detector 2 that contains pixel (spat,spec)=(2000,2121) and on
        # detector 3 that contains pixel (2000,2121).
        rm_slits = None
    # Define how to trace the slit tilts using the trace frames
    [[tilts]]
        # Only use the arc lines that have an identified wavelength to
        # trace tilts (CURRENTLY NOT USED!)
        idsonly = False
        # Significance threshold for arcs to be used in tracing
        # wavelength tilts. This can be a single number or a list/array
        # providing the value for each slit/order.
        tracethresh = 20.0
        # Significance threshold for arcs to be used in line
        # identification for the purpose of identifying neighboring
        # lines.The tracethresh parameter above determines the
        # significance threshold of lines that will be traced, but these
        # lines must be at least nfwhm_neigh fwhm away from neighboring
        # lines. This parameter determines the significance above which
        # a line must be to be considered a possible colliding neighbor.
        # A low value of sig_neigh will result in an overall larger
        # number of lines, which will result in more lines above
        # tracethresh getting rejected
        sig_neigh = 10.0
        # Required separation between neighboring arc lines for them to
        # be considered for tilt tracing in units of the the spectral
        # fwhm (see wavelength parset where fwhm is defined)
        nfwhm_neigh = 3.0
        # Maximum absolute deviation (in units of fwhm) for the legendre
        # polynomial fits to individual arc line tilt fits during
        # iterative trace fitting (flux weighted, then gaussian
        # weighted)
        maxdev_tracefit = 0.2
        # Outlier rejection significance to determine which traced arc
        # lines should be included in the global fit
        sigrej_trace = 3.0
        # Order of the legendre polynomial to be fit to the the tilt of
        # an arc line. This parameter determinesboth the orer of the
        # *individual* arc line tilts, as well as the order of the
        # spatial direction of the2d legendre polynomial (spatial,
        # spectral) that is fit to obtain a global solution for the
        # tilts across theslit/order. This can be a single number or a
        # list/array providing the value for each slit
        spat_order = 3
        # Order of the spectral direction of the 2d legendre polynomial
        # (spatial, spectral) that is fit to obtain a global solution
        # for the tilts across the slit/order. This can be a single
        # number or a list/array providing the value for each slit
        spec_order = 4
        # Type of function for 2D fit
        func2d = legendre2d
        # Maximum absolute deviation (in units of fwhm) rejection
        # threshold used to determines which pixels in global 2d fits to
        # arc line tilts are rejected because they deviate from the
        # model by more than this value
        maxdev2d = 0.25
        # Outlier rejection significance determining which pixels on a
        # fit to an arc line tilt are rejected by the global 2D fit
        sigrej2d = 3.0
        # Before tracing the line center at each spatial position,
        # remove any low-order continuum in the 2D spectra.
        rm_continuum = False
        # The sigma threshold for rejection.  Can be a single number or
        # two numbers that give the low and high sigma rejection,
        # respectively.
        cont_rej = 3, 1.5
        # Sets how far below the last measured tilt line is extrapolated
        # in tracewave.fit_tilts()
        minmax_extrap = 150.0, 1000.0
# The frames and combination rules for the science observations
[scienceframe]
    # Frame type.  Options are: align, arc, bias, dark, pinhole,
    # pixelflat, illumflat, science, standard, trace, tilt
    frametype = science
    # A master calibrations file to use if it exists.
    useframe = None
    # Used in identifying frames of this type.  This sets the minimum
    # and maximum allowed exposure times.  There must be two items in
    # the list.  Use None to indicate no limit; i.e., to select
    # exposures with any time greater than 30 sec, use exprng = [30,
    # None].
    exprng = None, None
    # Low level parameters used for basic image processing
    [[process]]
        # Trim the image to the detector supplied region
        trim = True
        # Convert the ADUs to electrons using the detector gain
        apply_gain = True
        # Orient the raw image into the PypeIt frame
        orient = True
        # Method used to fit the overscan. Options are: polynomial,
        # savgol, median
        overscan_method = savgol
        # Parameters for the overscan subtraction.  For 'polynomial',
        # set overcan_par = order, number of pixels, number of repeats ;
        # for 'savgol', set overscan_par = order, window size ; for
        # 'median', set overscan_par = None or omit the keyword.
        overscan_par = 5, 65
        # Method used to combine multiple frames.  Options are: median,
        # weightmean
        combine = weightmean
        # Handling of saturated pixels.  Options are: reject, force,
        # nothing
        satpix = reject
        # Identify CRs and mask them
        mask_cr = True
        # Perform sigma clipping when combining.  Only used with
        # combine=weightmean
        clip = True
        # Sigma level to reject cosmic rays (<= 0.0 means no CR removal)
        cr_sigrej = 20.0
        # Number of pixels to reject at the lowest and highest ends of
        # the distribution; i.e., n_lohi = low, high.  Use None for no
        # limit.
        n_lohi = 0, 0
        # If all pixels are rejected, replace them using this method.
        # Options are: min, max, mean, median, weightmean, maxnonsat
        replace = maxnonsat
        # Maximum number of iterations for LA cosmics routine.
        lamaxiter = 1
        # Factor by which to expand regions with cosmic rays detected by
        # the LA cosmics routine.
        grow = 1.5
        # Sigma-clipping level for when clip=True; Use None for
        # automatic limit (recommended).
        comb_sigrej = None
        # Remove compact detections in LA cosmics routine
        rmcompact = True
        # Sigma level for rejection in LA cosmics routine
        sigclip = 5.0
        # Fraction for the lower clipping threshold in LA cosmics
        # routine.
        sigfrac = 0.3
        # Object detection limit in LA cosmics routine
        objlim = 2.0
        # Use a bias image.  If True, one or more must be supplied in
        # the PypeIt file.
        use_biasimage = False
        # Subtract off the overscan.  Detector *must* have one or code
        # will crash.
        use_overscan = True
        # Subtract off a dark image.  If True, one or more darks must be
        # provided.
        use_darkimage = False
        # Use the pixel flat to make pixel-level corrections.  A
        # pixelflat image must be provied.
        use_pixelflat = True
        # Use the illumination flat to correct for the illumination
        # profile of each slit.
        use_illumflat = True
        # Use the relative spectral illumination profiles to correct the
        # spectralillumination profile of each slit. This is primarily
        # used for IFUs.
        use_specillum = False
        # Subtract off a detector pattern. This pattern is assumed to be
        # sinusoidalalong one direction, with a frequency that is
        # constant across the detector.
        use_pattern = False
        # Correct slits, illumination flat, etc. for flexure
        spat_flexure_correct = False
# Parameters determining sky-subtraction, object finding, and extraction
[reduce]
    # Trim the slit by this number of pixels left/right when performing
    # sky sub
    trim_edge = 0, 0
    # Parameters for the find object and tracing algorithms
    [[findobj]]
        # Order of legendre polynomial fits to object traces.
        trace_npoly = 5
        # Significance threshold for object finding.
        sig_thresh = 10.0
        # Trim the slit by this number of pixels left/right before
        # finding objects
        find_trim_edge = 5, 5
        # Fit a continuum to the illumination pattern across the trace
        # rectified image (masking objects) when searching for peaks to
        # initially identify objects
        find_cont_fit = True
        # Polynomial order for fitting continuum to the illumination
        # pattern across the trace rectified image (masking objects)
        # when searching for peaks to initially identify objects
        find_npoly_cont = 1
        # Maximum deviation of pixels from polynomial fit to trace used
        # to reject bad pixels in trace fitting.
        find_maxdev = 2.0
        # Polynomial order used for trace extrapolation
        find_extrap_npoly = 3
        # Maximum number of objects to extract in a science frame.  Use
        # None for no limit.
        maxnumber = 10
        # Indicates roughly the fwhm of objects in pixels for object
        # finding
        find_fwhm = 5.0
        # Criteria for keeping echelle objects. They must either have a
        # maximum S/N across all the orders greater than this value or
        # satisfy the min_snr criteria described by the min_snr
        # parameters
        ech_find_max_snr = 1.0
        # Criteria for keeping echelle objects. They must either have a
        # maximum S/N across all the orders greater than
        # ech_find_max_snr,  value or they must have S/N >
        # ech_find_min_snr on >= ech_find_nabove_min_snr orders
        ech_find_min_snr = 0.3
        # Criteria for keeping echelle objects. They must either have a
        # maximum S/N across all the orders greater than
        # ech_find_max_snr,  value or they must have S/N >
        # ech_find_min_snr on >= ech_find_nabove_min_snr orders
        ech_find_nabove_min_snr = 2
        # Only perform one round of object finding (mainly for
        # quick_look)
        skip_second_find = False
        # It defines the minimum and maximum of your object in the
        # spectral direction on thedetector. It only used for object
        # finding. This parameter is helpful if your object onlyhas
        # emission lines or at high redshift and the trace only shows in
        # part of the detector.
        find_min_max = None
    # Parameters for sky subtraction algorithms
    [[skysub]]
        # Break-point spacing for the bspline sky subtraction fits.
        bspline_spacing = 0.8
        # Rejection parameter for local sky subtraction
        sky_sigrej = 3.0
        # Global sky subtraction will be performed on standard stars.
        # This should be turnedoff for example for near-IR reductions
        # with narrow slits, since bright standards canfill the slit
        # causing global sky-subtraction to fail. In these situations we
        # go straight to local sky-subtraction since it is designed to
        # deal with such situations
        global_sky_std = False
        # Turn off polynomial basis (Legendre) in global sky subtraction
        no_poly = False
        # A user-defined sky regions mask can be set using this keyword.
        # To allowthe code to identify the sky regions automatically,
        # set this variable toan empty string. If you wish to set the
        # sky regions, The text should bea comma separated list of
        # percentages to apply to _all_ slits For example: The following
        # string   :10,35:65,80:   would select thefirst 10%, the inner
        # 30%, and the final 20% of _all_ slits.
        user_regions = None
        # Perform a simultaneous joint fit to sky regions using all
        # available slits.
        joint_fit = False
        # Load a user-defined sky regions mask to be used for the sky
        # regions. Note,if you set this to True, you must first run the
        # pypeit_skysub_regions GUIto manually select and store the
        # regions to file.
        load_mask = False
        # In global sky evaluation, mask the sky region around the
        # object by the boxcar radius (set in ExtractionPar).
        mask_by_boxcar = False
        # If True, turn off local sky model evaluation, but do fit
        # object profile and perform optimal extraction
        no_local_sky = False
    # Parameters for extraction algorithms
    [[extraction]]
        # Boxcar radius in arcseconds used for boxcar extraction
        boxcar_radius = 1.5
        # prof_nsigma parameter for Standard star extraction.  Prevents
        # undesired rejection.
        std_prof_nsigma = 30.0
        # S/N threshold for performing the more sophisticated optimal
        # extraction which performs a b-spline fit to the object
        # profile. For S/N < sn_gauss the code will simply optimal
        # extractwith a Gaussian with FWHM determined from the object
        # finding.
        sn_gauss = 4.0
        # If True local sky subtraction will be performed on the entire
        # slit. If False, local sky subtraction will be applied to only
        # a restricted region around each object. This should be set to
        # True for either multislit observations using narrow slits or
        # echelle observations with narrow slits
        model_full_slit = False
        # Perform boxcar extraction only (i.e. skip Optimal and local
        # skysub)
        skip_optimal = False
        # Mask pixels rejected during profile fitting when
        # extracting.Turning this off may help with bright emission
        # lines.
        use_2dmodel_mask = True
        # Parameters for manual extraction
        [[[manual]]]
            # List of spatial:spectral positions to hand extract, e.g.
            # "1243.3:1200," or "1243.3:1200,1345:1200
            spat_spec = None
            # List of detectors for hand extraction. This must be a list
            # aligned with the spec_spat list.  Negative values indicate
            # negative images.
            det = None
            # List of FWHM for hand extraction. This must be a list
            # aligned with spec_spat
            fwhm = None
    # Parameters for cube generation algorithms
    [[cube]]
        # If the data use slits in one spatial direction, set this to
        # True.If the data uses fibres for all spaxels, set this to
        # False.
        slit_spec = True
        # If set to True, the combined frames will use a relative
        # weighting scheme.This only works well if there is a common
        # continuum source in the field ofview of all input
        # observations, and is generally only required if highrelative
        # precision is desired.
        relative_weights = False
        # If set to True, the input frames will be combined. Otherwise,
        # a separatedatacube will be generated for each input spec2d
        # file.
        combine = True
        # Output filename of the combined datacube.
        output_filename = datacube.fits
        # Filename of a standard star datacube. This cube will be used
        # to correctthe relative scales of the slits, and to flux
        # calibrate the sciencedatacube.
        standard_cube = None
        # Flux calibrate the data? If True, you must also provide a
        # standard starcube using the standard_cube parameter.
        flux_calibrate = False
        # White light image of a previously combined datacube. The white
        # lightimage will be used as a reference when calculating the
        # offsets of theinput spec2d files.
        reference_image = None
        # Save a white light image of the combined datacube. The output
        # filenamewill be given by the "output_filename" variable with a
        # suffix "_whitelight".Note that the white light image collapses
        # the flux along the wavelength axis,so some spaxels in the 2D
        # white light image may have different wavelengthranges.
        save_whitelight = False
        # Minimum RA to use when generating the WCS. If None, the
        # default is minimum RAbased on the WCS of all spaxels. Units
        # should be degrees.
        ra_min = None
        # Maximum RA to use when generating the WCS. If None, the
        # default is maximum RAbased on the WCS of all spaxels. Units
        # should be degrees.
        ra_max = None
        # Minimum DEC to use when generating the WCS. If None, the
        # default is minimum DECbased on the WCS of all spaxels. Units
        # should be degrees.
        dec_min = None
        # Maximum DEC to use when generating the WCS. If None, the
        # default is maximum DECbased on the WCS of all spaxels. Units
        # should be degrees.
        dec_max = None
        # Minimum wavelength to use when generating the WCS. If None,
        # the default isminimum wavelength based on the WCS of all
        # spaxels. Units should be Angstroms.
        wave_min = None
        # Maximum wavelength to use when generating the WCS. If None,
        # the default ismaximum wavelength based on the WCS of all
        # spaxels. Units should be Angstroms.
        wave_max = None
        # The spatial size of each spaxel to use when generating the WCS
        # (in arcsec).If None, the default is set by the spectrograph
        # file.
        spatial_delta = None
        # The wavelength step to use when generating the WCS (in
        # Angstroms).If None, the default is set by the wavelength
        # solution.
        wave_delta = None
    # Parameters for slitmask
    [[slitmask]]
        # Tolerance (arcsec) to match source to targeted object
        obj_toler = 5.0
        # If SlitMask object was generated, assign RA,DEC,name to
        # objects
        assign_obj = False
# Parameters used by the flexure-correction procedure.  Flexure
# corrections are not performed by default.  To turn on, either set the
# parameters in the 'flexure' parameter group or set 'flexure = True' in
# the 'rdx' parameter group to use the default flexure-correction
# parameters.
[flexure]
    # Method used to correct for flexure. Use skip for no correction.
    # If slitcen is used, the flexure correction is performed before the
    # extraction of objects (not recommended).  Options are: None,
    # boxcar, slitcen, skip
    spec_method = skip
    # Maximum allowed spectral flexure shift in pixels.
    spec_maxshift = 20
    # Archive sky spectrum to be used for the flexure correction.
    spectrum = /home/tim/conda/envs/pypeit_release/lib/python3.8/site-packages/pypeit/data/sky_spec/paranal_sky.fits
# Parameters used by the flux-calibration procedure.  Flux calibration
# is not performed by default.  To turn on, either set the parameters in
# the 'fluxcalib' parameter group or set 'fluxcalib = True' in the 'rdx'
# parameter group to use the default flux-calibration parameters.
[fluxcalib]
    # If extinct_correct=True the code will use an atmospheric
    # extinction model to extinction correct the data below 10000A. Note
    # that this correction makes no sense if one is telluric correcting
    # and this shold be set to False
    extinct_correct = False
    # If False (default), the code will barf if one tries to use
    # sensfunc at wavelengths outside its defined domain. By changing
    # the par['sensfunc']['extrap_blu'] and
    # par['sensfunc']['extrap_red'] this domain can be extended. If True
    # the code will blindly extrapolate.
    extrap_sens = False
# Par set to control 1D coadds.  Only used in the after-burner script.
[coadd1d]
    # The extraction to coadd, i.e. optimal or boxcar. Must be either
    # 'OPT' or 'BOX'
    ex_value = OPT
    # If True (default), the code will coadd the fluxed spectra (i.e.
    # the FLAM) in the spec1d files. If False, it will coadd the counts.
    flux_value = True
    # Number of edge pixels to mask. This should be removed/fixed.
    nmaskedge = 2
    # Number of pixels to median filter by when computing S/N used to
    # decide how to scale and weight spectra. If set to None (default),
    # the code will determine the effective number of good pixels per
    # spectrum in the stack that is being co-added and use 10% of this
    # neff.
    sn_smooth_npix = None
    # Method used to construct wavelength grid for coadding spectra. The
    # routine that creates the wavelength is coadd1d.get_wave_grid. The
    # options are: 'iref' -- Use the first wavelength array'velocity' --
    # Grid is uniform in velocity'log10' -- Grid is uniform in
    # log10(wave).This is the same as velocity.'linear' -- Grid is
    # uniform in lamba.'concatenate' -- Meld the input wavelength arrays
    wave_method = linear
    # sampling factor to make the wavelength grid for sensitivity
    # function finer or coarser.  samp_fact > 1.0 oversamples (finer),
    # samp_fact < 1.0 undersamples (coarser).
    samp_fact = 1.0
    # Percentile used for selecting the minimum SNR cut from a reference
    # spectrum used to robustly determine the median ratio between
    # spectra. This parameter is used by coadd1d.robust_median_ratio as
    # part of the automatic rescaling procedure. Pixels above this
    # percentile cut are deemed the "good" pixels and are used to
    # compute the ratio of two spectra.  This must be a number between 0
    # and 100.
    ref_percentile = 70.0
    # Maximum number of iterations performed for rescaling spectra.
    maxiter_scale = 5
    # Rejection threshold used for rejecting pixels when rescaling
    # spectra with scale_spec.
    sigrej_scale = 3.0
    # Method used to rescale the spectra prior to coadding. The options
    # are: 'auto' -- Determine the scaling method automatically based on
    # the S/N ratio which works well'poly' -- Polynomial
    # rescaling.'median' -- Median rescaling'none' -- Do not
    # rescale.'hand' -- Pass in hand scaling factors. This option is not
    # well tested.
    scale_method = auto
    # For scale method set to 'auto', this sets the minimum SNR for
    # which median scaling is attempted
    sn_min_medscale = 0.5
    # For scale method set to 'auto', this sets the minimum SNR for
    # which polynomial scaling is attempted.
    sn_min_polyscale = 2.0
    # maximum number of iterations for stacking and rejection. The code
    # stops iterating either when the output mask does not change
    # betweeen successive iterations or when maxiter_reject is reached.
    maxiter_reject = 5
    # Lower rejection threshold used for rejecting pixels when combining
    # spectra in units of sigma.
    lower = 3.0
    # Upper rejection threshold used for rejecting pixels when combining
    # spectra in units of sigma.
    upper = 3.0
    # Coadding performs iterative rejection by comparing each exposure
    # to a preliminary stack of all the exposures. If this parameter is
    # set then it will not reject more than maxrej pixels per iteration
    # of this rejection. The default is None, which means no maximum on
    # rejected pixels.
    maxrej = None
    # Errors are capped during rejection so that the S/N is never
    # greater than sn_clip. This prevents overly aggressive rejection in
    # high S/N ratio spectrum which neverthless differ at a level
    # greater than the formal S/N due to systematics.
    sn_clip = 30.0
    # Number of orders to use for estimating the per exposure weights.
    # Default is None, which will just use one fourth of the total
    # number of orders. This is only used for Echelle
    nbest = None
    # File containing sensitivity function which is a requirement for
    # echelle coadds. This is only used for Echelle
    sensfuncfile = None
    # Output filename
    coaddfile = None
    # Magnitude type.  AB is the only option currently allowed
    mag_type = AB
    # Filter for scaling.  See flux_calib.load_fitler_file() for naming.
    # Ignore if none
    filter = none
    # Magnitude of the source in the given filter
    filter_mag = None
    # List of wavelength regions to mask when doing the scaling (ie.
    # occasional junk pixels).Colon and comma separateed, e.g.
    # 5552:5559,6010:6030
    filter_mask = None
    # If False (default), the code will barf in Echelle mode if one
    # tries to use sensfunc at wavelengths outside its defined domain.
    # By changing the par['sensfunc']['extrap_blu']and
    # par['sensfunc']['extrap_red'] this domain can be extended. If True
    # the code will blindly extrapolate.
    extrap_sens = False
# Par set to control 2D coadds.  Only used in the after-burner script.
[coadd2d]
    # User-input list of offsets for the images being combined (spat
    # pixels).
    offsets = None
    # Mode for the weights used to coadd images.  See coadd2d.py for all
    # options.
    weights = auto
    # If True, use the slits to set the trace down the center
    use_slits4wvgrid = False
# Par set to control sensitivity function computation.  Only used in the
# after-burner script.
[sensfunc]
    # Fraction of minimum wavelength coverage to grow the wavelength
    # coverage of the sensitivitity function in the blue direction, i.e.
    # if the standard star spectrumcuts off at wave_min, the sensfunc
    # will be extrapolated to cover down to  (1.0-extrap_blu)*wave_min
    extrap_blu = 0.1
    # Fraction of maximum wavelength coverage to grow the wavelength
    # coverage of the sensitivitity function in the red direction, i.e.
    # if the standard star spectrumcuts off at wave_max, the sensfunc
    # will be extrapolated to cover up to  (1.0 + extrap_red)*wave_max
    extrap_red = 0.1
    # sampling factor to make the wavelength grid for sensitivity
    # function finer or coarser.  samp_fact > 1.0 oversamples (finer),
    # samp_fact < 1.0 undersamples (coarser).
    samp_fact = 1.5
    # List of detector numbers to splice together for multi-detector
    # instruments (e.g. DEIMOS, GMOS). It is assumed that there is *no*
    # overlap in wavelength across detectors (might be ok if there is)
    multi_spec_det = None
    # Specify the algorithm for computing the sensitivity function. The
    # options are:  (1) UVIS = Should be used for data with lambda <
    # 7000A.No detailed model of telluric absorption but corrects for
    # atmospheric extinction. (2) IR = Should be used for data with
    # lambbda > 7000A.Peforms joint fit for sensitivity function and
    # telluric absorption using HITRAN models.
    algorithm = UVIS
    # Polynomial order for sensitivity function fitting
    polyorder = 7
    # Spectral type of the standard star (for near-IR mainly)
    star_type = None
    # Magnitude of the standard star (for near-IR mainly)
    star_mag = None
    # RA of the standard star. This will override values in the header,
    # i.e. if they are wrong or absent
    star_ra = None
    # DEC of the standard star. This will override values in the header,
    # i.e. if they are wrong or absent
    star_dec = None
    # Mask Balmer, Paschen, Brackett, and Pfund lines in sensitivity
    # function fit
    mask_abs_lines = True
    # Parameters for the UVIS sensfunc algorithm
    [[UVIS]]
        balm_mask_wid = 5.0
        std_file = None
        std_obj_id = None
        sensfunc = None
        extinct_correct = True
        telluric_correct = False
        telluric = False
        polycorrect = True
        polyfunc = False
        nresln = 20
        resolution = 3000.0
        trans_thresh = 0.9
    # Parameters for the IR sensfunc algorithm
    [[IR]]
        telgridfile = None
        sn_clip = 30.0
        resln_guess = None
        resln_frac_bounds = 0.5, 1.5
        pix_shift_bounds = -5.0, 5.0
        maxiter = 3
        sticky = True
        lower = 3.0
        upper = 3.0
        seed = 777
        tol = 0.001
        popsize = 30
        recombination = 0.7
        polish = True
        disp = False
# Par set to control telluric fitting.  Only used in the after-burner
# script.
[tellfit]
    # which object model you want to use for telluric fit
    objmodel = None
    # redshift for your object model
    redshift = 0.0
    # variable redshift range during the fit
    delta_redshift = 0.1
    # pca pickle file. needed when you use qso_telluric
    pca_file = /home/tim/conda/envs/pypeit_release/lib/python3.8/site-packages/pypeit/data/telluric/qso_pca_1200_3100.pckl
    # Number of pca
    npca = 8
    # Min/max wavelength of broad absorption features. If there are
    # several BAL features, the format for this mask is [wave_min_bal1,
    # wave_max_bal1,wave_min_bal2, wave_max_bal2,...]. These masked
    # pixels will be ignored during the fitting.
    bal_wv_min_max = None
    # Normalization bounds for scaling the initial object model
    bounds_norm = 0.1, 3.0
    # Threshold of telluric absorption region
    tell_norm_thresh = 0.9
    # order number if you only want to fit a single order
    only_orders = None
    # minimum wavelength for the pca model
    pca_lower = 1220.0
    # maximum wavelength for the pca model
    pca_upper = 3100.0
    # stellar type
    star_type = None
    # AB magnitude in V band
    star_mag = None
    # Object right-ascension in decimal deg
    star_ra = None
    # Object declination in decimal deg
    star_dec = None
    # Mask stellar absorption line?
    mask_abs_lines = True
    # object polynomial model function
    func = legendre
    # different type polynomial model. poly, square, exp corresponding
    # to normal polynomial,squared polynomial, or exponentiated
    # polynomial
    model = exp
    # polynomial order for the object model
    polyorder = 3
    # Pixels within this mask will be used during the fitting. The
    # formatis the same with bal_wv_min_max, but this mask is good pixel
    # masks.
    fit_wv_min_max = None
    # Mask the blueward of Lyman-alpha line during the fitting?
    mask_lyman_a = True
    # Paramters setting the polynomial coefficient bounds for telluric
    # optimization.
    delta_coeff_bounds = -20.0, 20.0
    # Paramters setting the polynomial coefficient bounds for telluric
    # optimization.
    minmax_coeff_bounds = -5.0, 5.0
    # telluric grid file. needed when you use qso_telluric
    tell_grid = None